import {
  ErrorCode,
  FormatError,
  IntlMessageFormat,
  TYPE,
  __assign,
  __extends,
  __rest,
  __spreadArray,
  isFormatXMLElementFn,
  memoize,
  strategies
} from "./chunk-IKY6R7GO.js";
import {
  require_react
} from "./chunk-CBG3MKAY.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment6 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment6;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/react-intl/lib/src/components/createFormattedComponent.js
var React4 = __toESM(require_react());

// node_modules/react-intl/lib/src/components/useIntl.js
var React3 = __toESM(require_react());

// node_modules/react-intl/lib/src/utils.js
var React = __toESM(require_react());

// node_modules/@formatjs/intl/lib/src/error.js
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = (
  /** @class */
  function(_super) {
    __extends(IntlError2, _super);
    function IntlError2(code, message, exception) {
      var _this = this;
      var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      _this = _super.call(this, "[@formatjs/intl Error ".concat(code, "] ").concat(message, "\n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
      _this.code = code;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, IntlError2);
      }
      return _this;
    }
    return IntlError2;
  }(Error)
);
var UnsupportedFormatterError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedFormatterError2, _super);
    function UnsupportedFormatterError2(message, exception) {
      return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
    }
    return UnsupportedFormatterError2;
  }(IntlError)
);
var InvalidConfigError = (
  /** @class */
  function(_super) {
    __extends(InvalidConfigError2, _super);
    function InvalidConfigError2(message, exception) {
      return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
    }
    return InvalidConfigError2;
  }(IntlError)
);
var MissingDataError = (
  /** @class */
  function(_super) {
    __extends(MissingDataError2, _super);
    function MissingDataError2(message, exception) {
      return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
    }
    return MissingDataError2;
  }(IntlError)
);
var IntlFormatError = (
  /** @class */
  function(_super) {
    __extends(IntlFormatError2, _super);
    function IntlFormatError2(message, locale, exception) {
      var _this = _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, "\nLocale: ").concat(locale, "\n"), exception) || this;
      _this.locale = locale;
      return _this;
    }
    return IntlFormatError2;
  }(IntlError)
);
var MessageFormatError = (
  /** @class */
  function(_super) {
    __extends(MessageFormatError2, _super);
    function MessageFormatError2(message, locale, descriptor, exception) {
      var _this = _super.call(this, "".concat(message, "\nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, "\n"), locale, exception) || this;
      _this.descriptor = descriptor;
      _this.locale = locale;
      return _this;
    }
    return MessageFormatError2;
  }(IntlFormatError)
);
var MissingTranslationError = (
  /** @class */
  function(_super) {
    __extends(MissingTranslationError2, _super);
    function MissingTranslationError2(descriptor, locale) {
      var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale, '", using ').concat(descriptor.defaultMessage ? "default message (".concat(typeof descriptor.defaultMessage === "string" ? descriptor.defaultMessage : descriptor.defaultMessage.map(function(e) {
        var _a;
        return (_a = e.value) !== null && _a !== void 0 ? _a : JSON.stringify(e);
      }).join(), ")") : "id", " as fallback.")) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MissingTranslationError2;
  }(IntlError)
);

// node_modules/@formatjs/intl/lib/src/utils.js
function invariant(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
function filterProps(props, allowlist, defaults) {
  if (defaults === void 0) {
    defaults = {};
  }
  return allowlist.reduce(function(filtered, name) {
    if (name in props) {
      filtered[name] = props[name];
    } else if (name in defaults) {
      filtered[name] = defaults[name];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error) {
  if (true) {
    console.error(error);
  }
};
var defaultWarnHandler = function(warning) {
  if (true) {
    console.warn(warning);
  }
};
var DEFAULT_INTL_CONFIG = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler,
  onWarn: defaultWarnHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache) {
  if (cache === void 0) {
    cache = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache(cache.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type, name, onError) {
  var formatType = formats && formats[type];
  var format;
  if (formatType) {
    format = formatType[name];
  }
  if (format) {
    return format;
  }
  onError(new UnsupportedFormatterError("No ".concat(type, " format named: ").concat(name)));
}

// node_modules/@formatjs/intl/lib/src/message.js
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all, k) {
    all[k] = __assign({ timeZone }, opts[k]);
    return all;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys = Object.keys(__assign(__assign({}, opts1), opts2));
  return keys.reduce(function(all, k) {
    all[k] = __assign(__assign({}, opts1[k] || {}), opts2[k] || {});
    return all;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
  if (!timeZone) {
    return f1;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign(__assign(__assign({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
}
var formatMessage = function(_a, state, messageDescriptor, values, opts) {
  var locale = _a.locale, formats = _a.formats, messages = _a.messages, defaultLocale = _a.defaultLocale, defaultFormats = _a.defaultFormats, fallbackOnEmptyString = _a.fallbackOnEmptyString, onError = _a.onError, timeZone = _a.timeZone, defaultRichTextElements = _a.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.github.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.github.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.github.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id = String(msgId);
  var message = (
    // In case messages is Object.create(null)
    // e.g import('foo.json') from webpack)
    // See https://github.com/formatjs/formatjs/issues/1914
    messages && Object.prototype.hasOwnProperty.call(messages, id) && messages[id]
  );
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values = __assign(__assign({}, defaultRichTextElements), values || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id, '", rendering default message verbatim'), locale, messageDescriptor, e));
        return typeof defaultMessage === "string" ? defaultMessage : id;
      }
    }
    return id;
  }
  try {
    var formatter = state.getMessageFormat(message, locale, formats, __assign({ formatters: state }, opts || {}));
    return formatter.format(values);
  } catch (e) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale, messageDescriptor, e));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
      return formatter.format(values);
    } catch (e) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id, '", rendering message verbatim'), locale, messageDescriptor, e));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id;
};

// node_modules/@formatjs/intl/lib/src/dateTime.js
var DATE_TIME_FORMAT_OPTIONS = [
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  // 'dayPeriod',
  "numberingSystem",
  "fractionalSecondDigits"
];
function getFormatter(_a, type, getDateTimeFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError, timeZone = _a.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = __assign(__assign({}, timeZone && { timeZone }), format && getNamedFormat(formats, type, format, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
  if (type === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign(__assign({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale, filteredOptions);
}
function formatDate(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return String(date);
}
function formatTime(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return String(date);
}
function formatDateTimeRange(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var from = _a[0], to = _a[1], _b = _a[2], options = _b === void 0 ? {} : _b;
  var fromDate = typeof from === "string" ? new Date(from || 0) : from;
  var toDate = typeof to === "string" ? new Date(to || 0) : to;
  try {
    return getFormatter(config, "dateTimeRange", getDateTimeFormat, options).formatRange(fromDate, toDate);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date time range.", config.locale, e));
  }
  return String(fromDate);
}
function formatDateToParts(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return [];
}
function formatTimeToParts(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return [];
}

// node_modules/@formatjs/intl/lib/src/displayName.js
var DISPLAY_NAMES_OPTONS = [
  "style",
  "type",
  "fallback",
  "languageDisplay"
];
function formatDisplayName(_a, getDisplayNames, value, options) {
  var locale = _a.locale, onError = _a.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale, filteredOptions).of(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting display name.", locale, e));
  }
}

// node_modules/@formatjs/intl/lib/src/list.js
var LIST_FORMAT_OPTIONS = [
  "type",
  "style"
];
var now = Date.now();
function generateToken(i) {
  return "".concat(now, "_").concat(i, "_").concat(now);
}
function formatList(opts, getListFormat, values, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values, options).reduce(function(all, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all.push(val);
    } else if (typeof all[all.length - 1] === "string") {
      all[all.length - 1] += val;
    } else {
      all.push(val);
    }
    return all;
  }, []);
  return results.length === 1 ? results[0] : results.length === 0 ? "" : results;
}
function formatListToParts(_a, getListFormat, values, options) {
  var locale = _a.locale, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values.map(function(v, i) {
      if (typeof v === "object") {
        var id = generateToken(i);
        richValues_1[id] = v;
        return id;
      }
      return String(v);
    });
    return getListFormat(locale, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign(__assign({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e) {
    onError(new IntlFormatError("Error formatting list.", locale, e));
  }
  return values;
}

// node_modules/@formatjs/intl/lib/src/plural.js
var PLURAL_FORMAT_OPTIONS = ["type"];
function formatPlural(_a, getPluralRules, value, options) {
  var locale = _a.locale, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale, filteredOptions).select(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting plural.", locale, e));
  }
  return "other";
}

// node_modules/@formatjs/intl/lib/src/relativeTime.js
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter2(_a, getRelativeTimeFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = !!format && getNamedFormat(formats, "relative", format, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
  return getRelativeTimeFormat(locale, filteredOptions);
}
function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter2(config, getRelativeTimeFormat, options).format(value, unit);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting relative time.", config.locale, e));
  }
  return String(value);
}

// node_modules/@formatjs/intl/lib/src/number.js
var NUMBER_FORMAT_OPTIONS = [
  "style",
  "currency",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  // ES2020 NumberFormat
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem",
  // ES2023 NumberFormat
  "trailingZeroDisplay",
  "roundingPriority",
  "roundingIncrement",
  "roundingMode"
];
function getFormatter3(_a, getNumberFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = format && getNamedFormat(formats, "number", format, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
  return getNumberFormat(locale, filteredOptions);
}
function formatNumber(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).format(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return String(value);
}
function formatNumberToParts(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).formatToParts(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return [];
}

// node_modules/@formatjs/intl/lib/src/create-intl.js
function messagesContainString(messages) {
  var firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config) {
  if (config.onWarn && config.defaultRichTextElements && messagesContainString(config.messages || {})) {
    config.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.github.io/docs/getting-started/message-distribution');
  }
}
function createIntl(config, cache) {
  var formatters = createFormatters(cache);
  var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG), config);
  var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale, '" as fallback. See https://formatjs.github.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.github.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.github.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign(__assign({}, resolvedConfig), { formatters, formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat), formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat), formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat), formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules), formatMessage: formatMessage.bind(null, resolvedConfig, formatters), $t: formatMessage.bind(null, resolvedConfig, formatters), formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat), formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters.getListFormat), formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames) });
}

// node_modules/react-intl/lib/src/utils.js
function invariant2(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
function invariantIntlContext(intl) {
  invariant2(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG2 = __assign(__assign({}, DEFAULT_INTL_CONFIG), { textComponent: React.Fragment });
var arbitraryKeyProps = { key: 42 };
var toArbitrarilyKeyedReactNode = function(reactNode) {
  return React.isValidElement(reactNode) ? React.createElement(React.Fragment, arbitraryKeyProps, reactNode) : reactNode;
};
var toKeyedReactNodeArray = function(children) {
  var _a;
  return (_a = React.Children.map(children, toArbitrarilyKeyedReactNode)) !== null && _a !== void 0 ? _a : [];
};
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(React.Children.toArray(parts));
  };
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/react-intl/lib/src/components/injectIntl.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var React2 = __toESM(require_react());
function getDisplayName(Component) {
  return Component.displayName || Component.name || "Component";
}
var IntlContext = typeof window !== "undefined" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = React2.createContext(null)) : React2.createContext(null);
var IntlConsumer = IntlContext.Consumer;
var IntlProvider = IntlContext.Provider;
var Provider = IntlProvider;
var Context = IntlContext;
function injectIntl(WrappedComponent, options) {
  var _a = options || {}, _b = _a.intlPropName, intlPropName = _b === void 0 ? "intl" : _b, _c = _a.forwardRef, forwardRef2 = _c === void 0 ? false : _c, _d = _a.enforceContext, enforceContext = _d === void 0 ? true : _d;
  var WithIntl = function(props) {
    return React2.createElement(IntlConsumer, null, function(intl) {
      var _a2;
      if (enforceContext) {
        invariantIntlContext(intl);
      }
      var intlProp = (_a2 = {}, _a2[intlPropName] = intl, _a2);
      return React2.createElement(WrappedComponent, __assign({}, props, intlProp, { ref: forwardRef2 ? props.forwardedRef : null }));
    });
  };
  WithIntl.displayName = "injectIntl(".concat(getDisplayName(WrappedComponent), ")");
  WithIntl.WrappedComponent = WrappedComponent;
  if (forwardRef2) {
    return (0, import_hoist_non_react_statics.default)(
      // @ts-expect-error
      React2.forwardRef(function(props, ref) {
        return React2.createElement(WithIntl, __assign({}, props, { forwardedRef: ref }));
      }),
      WrappedComponent
    );
  }
  return (0, import_hoist_non_react_statics.default)(WithIntl, WrappedComponent);
}

// node_modules/react-intl/lib/src/components/useIntl.js
function useIntl() {
  var intl = React3.useContext(Context);
  invariantIntlContext(intl);
  return intl;
}

// node_modules/react-intl/lib/src/components/createFormattedComponent.js
var DisplayName;
(function(DisplayName2) {
  DisplayName2["formatDate"] = "FormattedDate";
  DisplayName2["formatTime"] = "FormattedTime";
  DisplayName2["formatNumber"] = "FormattedNumber";
  DisplayName2["formatList"] = "FormattedList";
  DisplayName2["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function(DisplayNameParts2) {
  DisplayNameParts2["formatDate"] = "FormattedDateParts";
  DisplayNameParts2["formatTime"] = "FormattedTimeParts";
  DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
  DisplayNameParts2["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
var FormattedNumberParts = function(props) {
  var intl = useIntl();
  var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
  return children(intl.formatNumberToParts(value, formatProps));
};
FormattedNumberParts.displayName = "FormattedNumberParts";
var FormattedListParts = function(props) {
  var intl = useIntl();
  var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
  return children(intl.formatListToParts(value, formatProps));
};
FormattedNumberParts.displayName = "FormattedNumberParts";
function createFormattedDateTimePartsComponent(name) {
  var ComponentParts = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    var date = typeof value === "string" ? new Date(value || 0) : value;
    var formattedParts = name === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
    return children(formattedParts);
  };
  ComponentParts.displayName = DisplayNameParts[name];
  return ComponentParts;
}
function createFormattedComponent(name) {
  var Component = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(
      props,
      ["value", "children"]
    );
    var formattedValue = intl[name](value, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    var Text = intl.textComponent || React4.Fragment;
    return React4.createElement(Text, null, formattedValue);
  };
  Component.displayName = DisplayName[name];
  return Component;
}

// node_modules/react-intl/lib/src/components/createIntl.js
function assignUniqueKeysToFormatXMLElementFnArgument(values) {
  if (!values) {
    return values;
  }
  return Object.keys(values).reduce(function(acc, k) {
    var v = values[k];
    acc[k] = isFormatXMLElementFn(v) ? assignUniqueKeysToParts(v) : v;
    return acc;
  }, {});
}
var formatMessage2 = function(config, formatters, descriptor, rawValues) {
  var rest = [];
  for (var _i = 4; _i < arguments.length; _i++) {
    rest[_i - 4] = arguments[_i];
  }
  var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks = formatMessage.apply(void 0, __spreadArray([
    config,
    formatters,
    descriptor,
    values
  ], rest, false));
  if (Array.isArray(chunks)) {
    return toKeyedReactNodeArray(chunks);
  }
  return chunks;
};
var createIntl2 = function(_a, cache) {
  var rawDefaultRichTextElements = _a.defaultRichTextElements, config = __rest(_a, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl(__assign(__assign(__assign({}, DEFAULT_INTL_CONFIG2), config), { defaultRichTextElements }), cache);
  var resolvedConfig = {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  };
  return __assign(__assign({}, coreIntl), { formatMessage: formatMessage2.bind(null, resolvedConfig, coreIntl.formatters), $t: formatMessage2.bind(null, resolvedConfig, coreIntl.formatters) });
};

// node_modules/react-intl/lib/src/components/dateTimeRange.js
var React5 = __toESM(require_react());
var FormattedDateTimeRange = function(props) {
  var intl = useIntl();
  var from = props.from, to = props.to, children = props.children, formatProps = __rest(props, ["from", "to", "children"]);
  var formattedValue = intl.formatDateTimeRange(from, to, formatProps);
  if (typeof children === "function") {
    return children(formattedValue);
  }
  var Text = intl.textComponent || React5.Fragment;
  return React5.createElement(Text, null, formattedValue);
};
FormattedDateTimeRange.displayName = "FormattedDateTimeRange";
var dateTimeRange_default = FormattedDateTimeRange;

// node_modules/react-intl/lib/src/components/message.js
var React6 = __toESM(require_react());
function areEqual(prevProps, nextProps) {
  var values = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage3 = intl.formatMessage, _a = intl.textComponent, Text = _a === void 0 ? React6.Fragment : _a;
  var id = props.id, description = props.description, defaultMessage = props.defaultMessage, values = props.values, children = props.children, _b = props.tagName, Component = _b === void 0 ? Text : _b, ignoreTag = props.ignoreTag;
  var descriptor = { id, description, defaultMessage };
  var nodes = formatMessage3(descriptor, values, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component) {
    return React6.createElement(Component, null, nodes);
  }
  return React6.createElement(React6.Fragment, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = React6.memo(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";
var message_default = MemoizedFormattedMessage;

// node_modules/react-intl/lib/src/components/plural.js
var React7 = __toESM(require_react());
var FormattedPlural = function(props) {
  var _a = useIntl(), formatPlural2 = _a.formatPlural, Text = _a.textComponent;
  var value = props.value, other = props.other, children = props.children;
  var pluralCategory = formatPlural2(value, props);
  var formattedPlural = props[pluralCategory] || other;
  if (typeof children === "function") {
    return children(formattedPlural);
  }
  if (Text) {
    return React7.createElement(Text, null, formattedPlural);
  }
  return formattedPlural;
};
FormattedPlural.displayName = "FormattedPlural";
var plural_default = FormattedPlural;

// node_modules/react-intl/lib/src/components/provider.js
var React8 = __toESM(require_react());
function processIntlConfig(config) {
  return {
    locale: config.locale,
    timeZone: config.timeZone,
    fallbackOnEmptyString: config.fallbackOnEmptyString,
    formats: config.formats,
    textComponent: config.textComponent,
    messages: config.messages,
    defaultLocale: config.defaultLocale,
    defaultFormats: config.defaultFormats,
    onError: config.onError,
    onWarn: config.onWarn,
    wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
    defaultRichTextElements: config.defaultRichTextElements
  };
}
var IntlProvider2 = (
  /** @class */
  function(_super) {
    __extends(IntlProvider3, _super);
    function IntlProvider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = createIntlCache();
      _this.state = {
        cache: _this.cache,
        intl: createIntl2(processIntlConfig(_this.props), _this.cache),
        prevConfig: processIntlConfig(_this.props)
      };
      return _this;
    }
    IntlProvider3.getDerivedStateFromProps = function(props, _a) {
      var prevConfig = _a.prevConfig, cache = _a.cache;
      var config = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config)) {
        return {
          intl: createIntl2(config, cache),
          prevConfig: config
        };
      }
      return null;
    };
    IntlProvider3.prototype.render = function() {
      invariantIntlContext(this.state.intl);
      return React8.createElement(Provider, { value: this.state.intl }, this.props.children);
    };
    IntlProvider3.displayName = "IntlProvider";
    IntlProvider3.defaultProps = DEFAULT_INTL_CONFIG2;
    return IntlProvider3;
  }(React8.PureComponent)
);
var provider_default = IntlProvider2;

// node_modules/react-intl/lib/src/components/relative.js
var React9 = __toESM(require_react());
var MINUTE = 60;
var HOUR = 60 * 60;
var DAY = 60 * 60 * 24;
function selectUnit(seconds) {
  var absValue = Math.abs(seconds);
  if (absValue < MINUTE) {
    return "second";
  }
  if (absValue < HOUR) {
    return "minute";
  }
  if (absValue < DAY) {
    return "hour";
  }
  return "day";
}
function getDurationInSeconds(unit) {
  switch (unit) {
    case "second":
      return 1;
    case "minute":
      return MINUTE;
    case "hour":
      return HOUR;
    default:
      return DAY;
  }
}
function valueToSeconds(value, unit) {
  if (!value) {
    return 0;
  }
  switch (unit) {
    case "second":
      return value;
    case "minute":
      return value * MINUTE;
    default:
      return value * HOUR;
  }
}
var INCREMENTABLE_UNITS = [
  "second",
  "minute",
  "hour"
];
function canIncrement(unit) {
  if (unit === void 0) {
    unit = "second";
  }
  return INCREMENTABLE_UNITS.indexOf(unit) > -1;
}
var SimpleFormattedRelativeTime = function(props) {
  var _a = useIntl(), formatRelativeTime2 = _a.formatRelativeTime, Text = _a.textComponent;
  var children = props.children, value = props.value, unit = props.unit, otherProps = __rest(props, ["children", "value", "unit"]);
  var formattedRelativeTime = formatRelativeTime2(value || 0, unit, otherProps);
  if (typeof children === "function") {
    return children(formattedRelativeTime);
  }
  if (Text) {
    return React9.createElement(Text, null, formattedRelativeTime);
  }
  return React9.createElement(React9.Fragment, null, formattedRelativeTime);
};
var FormattedRelativeTime = function(_a) {
  var _b = _a.value, value = _b === void 0 ? 0 : _b, _c = _a.unit, unit = _c === void 0 ? "second" : _c, updateIntervalInSeconds = _a.updateIntervalInSeconds, otherProps = __rest(_a, ["value", "unit", "updateIntervalInSeconds"]);
  invariant2(!updateIntervalInSeconds || !!(updateIntervalInSeconds && canIncrement(unit)), "Cannot schedule update with unit longer than hour");
  var _d = React9.useState(), prevUnit = _d[0], setPrevUnit = _d[1];
  var _e = React9.useState(0), prevValue = _e[0], setPrevValue = _e[1];
  var _f = React9.useState(0), currentValueInSeconds = _f[0], setCurrentValueInSeconds = _f[1];
  var updateTimer;
  if (unit !== prevUnit || value !== prevValue) {
    setPrevValue(value || 0);
    setPrevUnit(unit);
    setCurrentValueInSeconds(canIncrement(unit) ? valueToSeconds(value, unit) : 0);
  }
  React9.useEffect(function() {
    function clearUpdateTimer() {
      clearTimeout(updateTimer);
    }
    clearUpdateTimer();
    if (!updateIntervalInSeconds || !canIncrement(unit)) {
      return clearUpdateTimer;
    }
    var nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
    var nextUnit = selectUnit(nextValueInSeconds);
    if (nextUnit === "day") {
      return clearUpdateTimer;
    }
    var unitDuration2 = getDurationInSeconds(nextUnit);
    var remainder = nextValueInSeconds % unitDuration2;
    var prevInterestingValueInSeconds = nextValueInSeconds - remainder;
    var nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds ? prevInterestingValueInSeconds - unitDuration2 : prevInterestingValueInSeconds;
    var delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);
    if (currentValueInSeconds !== nextInterestingValueInSeconds) {
      updateTimer = setTimeout(function() {
        return setCurrentValueInSeconds(nextInterestingValueInSeconds);
      }, delayInSeconds * 1e3);
    }
    return clearUpdateTimer;
  }, [currentValueInSeconds, updateIntervalInSeconds, unit]);
  var currentValue = value || 0;
  var currentUnit = unit;
  if (canIncrement(unit) && typeof currentValueInSeconds === "number" && updateIntervalInSeconds) {
    currentUnit = selectUnit(currentValueInSeconds);
    var unitDuration = getDurationInSeconds(currentUnit);
    currentValue = Math.round(currentValueInSeconds / unitDuration);
  }
  return React9.createElement(SimpleFormattedRelativeTime, __assign({ value: currentValue, unit: currentUnit }, otherProps));
};
FormattedRelativeTime.displayName = "FormattedRelativeTime";
var relative_default = FormattedRelativeTime;

// node_modules/react-intl/lib/index.js
function defineMessages(msgs) {
  return msgs;
}
function defineMessage(msg) {
  return msg;
}
var FormattedDate = createFormattedComponent("formatDate");
var FormattedTime = createFormattedComponent("formatTime");
var FormattedNumber = createFormattedComponent("formatNumber");
var FormattedList = createFormattedComponent("formatList");
var FormattedDisplayName = createFormattedComponent("formatDisplayName");
var FormattedDateParts = createFormattedDateTimePartsComponent("formatDate");
var FormattedTimeParts = createFormattedDateTimePartsComponent("formatTime");
export {
  FormattedDate,
  FormattedDateParts,
  dateTimeRange_default as FormattedDateTimeRange,
  FormattedDisplayName,
  FormattedList,
  FormattedListParts,
  message_default as FormattedMessage,
  FormattedNumber,
  FormattedNumberParts,
  plural_default as FormattedPlural,
  relative_default as FormattedRelativeTime,
  FormattedTime,
  FormattedTimeParts,
  Context as IntlContext,
  provider_default as IntlProvider,
  InvalidConfigError,
  MessageFormatError,
  MissingDataError,
  MissingTranslationError,
  Provider as RawIntlProvider,
  IntlError as ReactIntlError,
  IntlErrorCode as ReactIntlErrorCode,
  UnsupportedFormatterError,
  createIntl2 as createIntl,
  createIntlCache,
  defineMessage,
  defineMessages,
  injectIntl,
  useIntl
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-intl.js.map
