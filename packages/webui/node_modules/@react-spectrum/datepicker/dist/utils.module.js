import {createDOMRef as $kDnTZ$createDOMRef} from "@react-spectrum/utils";
import {createFocusManager as $kDnTZ$createFocusManager} from "@react-aria/focus";
import {useDateFormatter as $kDnTZ$useDateFormatter, useLocale as $kDnTZ$useLocale} from "@react-aria/i18n";
import $kDnTZ$react, {useMemo as $kDnTZ$useMemo, useState as $kDnTZ$useState, useRef as $kDnTZ$useRef, useImperativeHandle as $kDnTZ$useImperativeHandle} from "react";
import {useDisplayNames as $kDnTZ$useDisplayNames} from "@react-aria/datepicker";
import {useLayoutEffect as $kDnTZ$useLayoutEffect} from "@react-aria/utils";
import {useProvider as $kDnTZ$useProvider} from "@react-spectrum/provider";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 






function $ea94a5cfe92db3c2$export$322f4580ccd8dde6(props) {
    let formatter = (0, $kDnTZ$useDateFormatter)({
        dateStyle: 'short'
    });
    let displayNames = (0, $kDnTZ$useDisplayNames)();
    return (0, $kDnTZ$useMemo)(()=>{
        if (props.description) return props.description;
        if (props.showFormatHelpText) return formatter.formatToParts(new Date()).map((s, i)=>{
            if (s.type === 'literal' || s.type === 'unknown' || s.type === 'yearName') return /*#__PURE__*/ (0, $kDnTZ$react).createElement("span", {
                key: i
            }, ` ${s.value} `);
            let type = s.type === 'relatedYear' ? 'year' : s.type;
            return /*#__PURE__*/ (0, $kDnTZ$react).createElement("span", {
                key: i,
                style: {
                    unicodeBidi: 'embed',
                    direction: 'ltr'
                }
            }, displayNames.of(type));
        });
        return '';
    }, [
        props.description,
        props.showFormatHelpText,
        formatter,
        displayNames
    ]);
}
function $ea94a5cfe92db3c2$export$12ce2869ce471b1f(maxVisibleMonths) {
    let { scale: scale } = (0, $kDnTZ$useProvider)();
    let [visibleMonths, setVisibleMonths] = (0, $kDnTZ$useState)($ea94a5cfe92db3c2$var$getVisibleMonths(scale));
    (0, $kDnTZ$useLayoutEffect)(()=>{
        let onResize = ()=>setVisibleMonths($ea94a5cfe92db3c2$var$getVisibleMonths(scale));
        onResize();
        window.addEventListener('resize', onResize);
        return ()=>{
            window.removeEventListener('resize', onResize);
        };
    }, [
        scale
    ]);
    return Math.max(1, Math.min(visibleMonths, maxVisibleMonths, 3));
}
function $ea94a5cfe92db3c2$var$getVisibleMonths(scale) {
    if (typeof window === 'undefined') return 1;
    let monthWidth = scale === 'large' ? 336 : 280;
    let gap = scale === 'large' ? 30 : 24;
    let popoverPadding = scale === 'large' ? 32 : 48;
    return Math.floor((window.innerWidth - popoverPadding * 2) / (monthWidth + gap));
}
function $ea94a5cfe92db3c2$export$71a23a36270e4bf0(ref) {
    let domRef = (0, $kDnTZ$useRef)(null);
    (0, $kDnTZ$useImperativeHandle)(ref, ()=>({
            ...(0, $kDnTZ$createDOMRef)(domRef),
            focus () {
                (0, $kDnTZ$createFocusManager)(domRef).focusFirst({
                    tabbable: true
                });
            }
        }));
    return domRef;
}
function $ea94a5cfe92db3c2$export$31e22e3c931fc056(state) {
    var _useLocale;
    let locale = (_useLocale = (0, $kDnTZ$useLocale)()) === null || _useLocale === void 0 ? void 0 : _useLocale.locale;
    let currentDate = new Date();
    let formatedDate = state.getDateFormatter(locale, {
        shouldForceLeadingZeros: true
    }).format(currentDate);
    let totalCharacters = formatedDate.length;
    // The max of two is for times with only hours.
    // As the length of a date grows we need to proportionally increase the width.
    // We use the character count with 'ch' units and add extra padding to accomate for
    // dates with months and time dashes, which are wider characters.
    return totalCharacters + Math.max(Math.floor(totalCharacters / 5), 2);
}


export {$ea94a5cfe92db3c2$export$322f4580ccd8dde6 as useFormatHelpText, $ea94a5cfe92db3c2$export$12ce2869ce471b1f as useVisibleMonths, $ea94a5cfe92db3c2$export$71a23a36270e4bf0 as useFocusManagerRef, $ea94a5cfe92db3c2$export$31e22e3c931fc056 as useFormattedDateWidth};
//# sourceMappingURL=utils.module.js.map
